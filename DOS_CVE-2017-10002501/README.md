# Remote crash most linux devices with bluetooth open

***Only for linux devices***

## Explication de la vulnérabilité

**Description du *Logical link control and adaptation protocol* (L2CAP)**

Côté hôte, la couche la plus basse de la pile Bluetooth est L2CAP. Cette couche est responsable de gérer les connexions aux différents services Bluetooth et de transmettre les paquets au *Host Controller Interface* (HCI).


En général, L2CAP peut être considéré comme l'équivalent de Bluetooth de TCP et ses fonctions sont :

- Transport de données pour les protocoles de couche supérieure, y compris le multiplexage de plusieurs applications sur un même lien.
- Segmentation et réassemblage des paquets.
- Fourniture d'une gestion de transmission unidirectionnelle des données de multicast à un groupe d'autres périphériques Bluetooth.
- Gestion de la qualité de service (QoS) pour les protocoles de couche supérieure.

Le transport sous-jacent de L2CAP est le transport logique ACL - *Asynchronous Connection-Oriented Logical transport*. La liste de contrôle d'accès est simplement la couche de transport orientée sur les paquets, non fiable, sur laquelle presque toutes les données Bluetooth sont transmises.
L2CAP gère les canaux orientés connexion sur ACL, qui sont des transports logiques de bout en bout identifiés par des identifiants de canaux dans le corps du paquet. Le rôle de ces identifiants de canaux peut être comparé au port utilisé dans les applications TCP (ou UDP).

La spécification Bluetooth réserve des CID spécifiques (identifiants de canaux) à des fins fixes, par exemple, CID 0x0001 se référera toujours au canal de signalisation dans lequel les paquets de contrôle sont passés (et à travers eux - de nouvelles connexions peuvent être établies). Les autres CID sont gérés et alloués dynamiquement.

Les divers services via Bluetooth ont souvent des PSM fixes (Protocol / Service Multiplexer - un autre terme L2CAP signifiant le numéro de port). Un point de terminaison souhaitant se connecter à ces services enverrait un message L2CAP ConnectionRequest à ce PSM spécifique. En réponse à ce message, un CID dynamique serait alloué pour identifier la connexion à ce service spécifique.

**Le processus de configuration** a lieu à l'aide de demandes de configuration et de réponses, appelées dans la spécification `L2CAP_ConfReq` et `L2CAP_ConfResp`. Chaque extrémité négocie sa propre configuration, ce qui signifie que les paramètres de configuration des deux points de terminaison doivent être convenus. Un exemple de configuration de MTU ci-dessous.

![alt text](https://github.com/AxelRoudaut/THC_BlueBorne/blob/master/images/l2cap_mutual_conf.PNG)

Il existe 2 types de processus de configuration:
  * “The standard configuration process”* dans lequel les extrémités répondront à une demande de configuration avec une réponse
qui accepte ou rejette la configuration offerte. Si une configuration a été rejetée, les terminaux continueront à négocier jusqu'à ce qu'ils atteignent une configuration convenue.
  * “The lockstep configuration process”*. Ce processus est nécessaire pour faciliter la fonctionnalité EFS (*Extended Flow Specification*) de L2CAP, qui permet aux périphériques d'établir une connexion plus complète. Les paramètres de la fonction EFS devront être validés avec chacun des contrôleurs Bluetooth locaux des points de terminaison, de sorte que la réponse des points de terminaison à une demande de configuration puisse être "En attente" (= *PENDING*). Une fois que les deux paramètres EFS ont été échangés entre les points d'extrémité et que la validation de l'EFS a été effectuée, une réponse finale sera renvoyée par chacun des points d'extrémité.
  
**Linux kernel RCE vulnerability - CVE-2017-1000251**

La vulnérabilité réside dans l'implémentation par BlueZ de la fonctionnalité EFS de L2CAP nommée `l2cap_parse_conf_rsp`.

  - [l2cap_parse_conf_rsp](https://elixir.bootlin.com/linux/v3.12.36/source/net/bluetooth/l2cap_core.c#L3482)
      ```
      Excerpt from l2cap_parse_conf_rsp (net/bluetooth/l2cap_core.c):

      static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len, void *data, u16 *result) 
      {
        struct l2cap_conf_req *req = data;
        void *ptr = req->data;
        // ...
        while (len >= L2CAP_CONF_OPT_SIZE) {
          len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
            switch (type) {

            case L2CAP_CONF_MTU:
              // Validate MTU...
              l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
              break;

            case L2CAP_CONF_FLUSH_TO:
              chan->flush_to = val;
              l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
              2, chan->flush_to);
              break;
          // ...
          }
        }
        // ...
        return ptr - data;
      }
      ```

Cette fonction reçoit un buffer (=tampon) de réponse de configuration (dans l'argument `rsp`) et sa longueur (dans l'argument `len`). Il extrait les éléments du tampon un par un à l'aide de la fonction `l2cap_get_conf_opt`, jusqu'à ce que l'argument `len` soit épuisé. Chaque élément qu'il décompresse de la réponse de la configuration est validé puis remis dans un tampon de réponse, pointé par l'argument de données.
Toutefois, la taille de ce buffer de réponse n'est pas transmise dans la fonction. Donc fondamentalement, tous les éléments de la RSP seraient copiés dans le tampon de données via `& ptr` (offset à `l2cap_conf_req.data`) quelle que soit la taille de la mémoire du buffer de la cible.
Notez également que la taille de la réponse entrante n'étant pas limitée - les éléments peuvent être dupliqués, ce qui permet à un attaquant de contrôler la taille du buffer `rsp` et, par conséquent, la quantité de données copiées sur les données.

L'origine du buffer de données dans `l2cap_parse_conf_rsp` est appelée à partir de deux emplacements, tous deux dans une fonction appelée `l2cap_config_rsp`, qui, comme son nom l'indique, gère les messages de réponse de configuration. Les deux invocations sont similaires, donc les deux peuvent être utilisés pour exploiter cette vulnérabilité.

  - [l2cap_config_rsp](https://elixir.bootlin.com/linux/v3.12.36/source/net/bluetooth/l2cap_core.c#L4081)
       ```
      Excerpt from l2cap_config_rsp (net/bluetooth/l2cap_core.c):

      switch (result) {
      case L2CAP_CONF_SUCCESS:
        // ...
        break;
      case L2CAP_CONF_PENDING:
        set_bit(CONF_REM_CONF_PEND, &chan->conf_state);
        if (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
          char buf[64];
          len = l2cap_parse_conf_rsp(chan, rsp->data, len, buf, &result);
        // ...
        goto done;
      // ...
      ``` 

Le `switch` examine la valeur de résultat, qui a été précédemment décompressée à partir du paquet de réponse de configuration, et peut donc être contrôlée par un attaquant. Le buffer de réponse est un petit buffer de pile, nommé `buf`, déclaré dans la portée de l'instruction `if` qui conduit à l'appel.

La configuration du canal actuel est ensuite testée pour l'état `PENDING` (comme décrit ci-dessus dans le processus de configuration *lockstep*). Donc, pour accéder à ce flux, un attaquant a besoin que sa cible soit dans l'état `PENDING`.

- [l2cap_parse_conf_req](https://elixir.bootlin.com/linux/v3.12.36/source/net/bluetooth/l2cap_core.c#L3268)
  ```
    Excerpt from l2cap_parse_conf_req (net/bluetooth/l2cap_core.c) :
	
    if (result == L2CAP_CONF_SUCCESS) {
      /* Configure output options and let the other side know
       * which ones we don't like. */
      // ...
      if (remote_efs) {
      if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
          efs.stype != L2CAP_SERV_NOTRAFIC &&
          efs.stype != chan->local_stype) {
        // We don’t want this branch, easy to avoid
        // ...
      } else {
         /* Send PENDING Conf Rsp */
         result = L2CAP_CONF_PENDING;
         set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
      }
    }
    // ...
    ```

Cette action est simple: un attaquant doit seulement envoyer une demande de configuration avec un élément EFS, en définissant le champ `stype` sur `L2CAP_SERV_NOTRAFIC`.

Lorsque l'état `PENDING` est atteint, la réponse de configuration suivante envoyée avec le champ résultat défini sur `L2CAP_CONF_PENDING` déclenche la vulnérabilité, amenant le tampon `buf [64]` à être remplacé par un tampon de taille arbitraire.
Cette vulnérabilité permet à un attaquant de déborder un tampon de 64 octets sur la pile du noyau par une quantité illimitée de données, à condition qu'elle soit conforme à la structure d'une réponse de configuration L2CAP valide.


**Exploitabilité**

Aujourd'hui, un débordement de pile comme la vulnérabilité décrite ci-dessus ne se traduit pas automatiquement par l'exécution de code. Les systèmes d'exploitation modernes ont des techniques d'atténuation spécialement conçues pour prévenir les vulnérabilités de corruption de la mémoire résultant de l'exécution de code (c'est pourquoi sur notre Ubuntu cible, cette attaque n'aboutira uniquement qu'à un déni de service). Malgré cela, le noyau Linux est parfois à la traîne dans l'implémentation de certaines *mitigations* modernes avec les configurations par défaut.

**Impact**

Dans le cas de BlueZ, L2CAP est inclus dans le noyau du noyau Linux. C'est un choix plutôt dangereux. La combinaison d'un protocole de communication entièrement exposé, des fonctionnalités arcanes comme EFS et une implémentation de l'espace noyau est une recette pour les problèmes. Cette vulnérabilité est un débordement de pile classique se produisant dans le contexte d'un thread de noyau. Cela fournit à un attaquant un exploit au niveau du noyau complet et fiable pour tout périphérique compatible Bluetooth sous Linux, ne nécessitant aucune étape supplémentaire. De plus, chaque hôte compromis peut être utilisé pour lancer des attaques secondaires, ce qui rend cette vulnérabilité vermifuge.

## Explication du challenge

Tout d'abord le script créé une socket Bluetooth et y associer les adresses et demandes d'informations necessaires (`Part1`), nous ne nous interesserons pas à cette partie.

Ensuite (`Part2`), nous envoyons une `L2CAP Connection Request` en utilisant le channel ID 0x40 et le PSM 0x01 pour y envoyer ensuite certaines données de configuration. On peut ici faire l'analogie avec l'ouverure d'une connexion TCP sur un certain port sur lequel on va envoyer ensuite notre *payload*. 

![alt text](https://github.com/AxelRoudaut/THC_BlueBorne/blob/master/images/conn_req.PNG)

En `Part3` nous allons envoyer une `L2CAP Configuration Request` dans le but d'acceder ensuite à la partie du code vulnérable. Nous avons vu précédemment que pour réaliser notre DOS il va falloire provoquer l'appel de la fonction ` l2cap_parse_conf_rsp` par le système cible. Pour celà, nous envoyons une *configuration request* car dans la fonction `l2cap_config_rsp` on remarque que dans le `case L2CAP_CONF_PENDING`, la fonction cible `l2cap_parse_conf_rsp` est appelée. Or comment obtenir ce statut `L2CAP_CONF_PENDING` ? Grâce à la fonction `l2cap_parse_conf_req` que la victime va appeler en recevant notre *L2CAP Configuration Request*, en profitant de l'astuce décrite précedemment :
```
if (remote_efs) {
    if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
    	efs.stype != L2CAP_SERV_NOTRAFIC &&
	efs.stype != chan->local_stype) {
	... // Cette condition est facile à éviter en ajoutant efs.stype=L2CAP_SERV_NOTRAFIC à notre conf_req
    } else {
        /* Send PENDING Conf Rsp */
        result = L2CAP_CONF_PENDING;	// ainsi on acquière le statu de PENDING 
        set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
    }
}
```
![alt text](https://github.com/AxelRoudaut/THC_BlueBorne/blob/master/images/conf_req.PNG)
**Question 1**
Retrouvez comment implémenter cette astuce (écrire pour atteindre la partie du code vulnérable.

Enfin en `Part4`, maintanant que nous avons réussi à obtenir le status `PENDING`, nous envoyons une *Configuration Response* avec le statut `L2CAP_CONF_PENDING`, amenant le tampon `buf [64]` à être remplacé par un tampon de taille arbitraire. La taille de notre buffer  `l2cap_command_3` n'est alors plus contrôlée donc on peut effectuer notre *buffer overflow* à condition qu'elle soit conforme à la structure d'une réponse de configuration L2CAP valide.

**Question 2**
Construire la `conf_resp` de manière à réussir l'overflow.

![alt text](https://github.com/AxelRoudaut/THC_BlueBorne/blob/master/images/conf_resp.PNG)

Nous avons réussi à faire un DOS total de la machine cible. Cette exploit pourrait être améliorer en exploit Kernel (RCE) sur la machine cible. Cepeandant il est difficile d'à la fois respecter la structure de réponse L2CAP valide et de contourner les protections du noyau (canarie, ASLR).
