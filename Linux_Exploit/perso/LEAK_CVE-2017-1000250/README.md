# Remote leak heap data from linux devices with bluetooth opened and discoverabled

***Only for linux devices***

```
gcc -o leak challenge_leak_part1.c -lbluetooth
sudo ./leak [Addr_BT_Target] [Leak_Offset]
```

Notice: In order to capture bluetooth packets from Wireshark from remote PC
```
sudo apt-get install libpcap0.8 libpcap0.8-dev libpcap-dev
ssh root@[addr raspberry] "sudo tcpdump -s 0 -U -n -i bluetooth1 -w -"  | sudo wireshark -k -i -
```

Here the white paper explaining the vulnerabilities: [link](http://go.armis.com/hubfs/BlueBorne%20Technical%20White%20Paper-1.pdf?t=1517293112971)

Here the Bluez code of the vulnerable function [service_search_attr_req](https://sourcecodebrowser.com/bluez/4.81/sdpd-request_8c.html#a88a67e8cc83d0f53b65629478bc16a06)

Here I highlight the vulnerable part of the code:  https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L132-L144 

Here some informations about the functions:
  - [socket()](http://pubs.opengroup.org/onlinepubs/7908799/xns/socket.html)
  - [bind()](http://pubs.opengroup.org/onlinepubs/7908799/xns/bind.html)
  - [connect()](http://pubs.opengroup.org/onlinepubs/7908799/xns/connect.html)
  - [send()](http://pubs.opengroup.org/onlinepubs/7908799/xns/send.html)
  - [recv()](http://pubs.opengroup.org/onlinepubs/7908799/xns/recv.html)
  - [Here more explanations about this functions](http://www.i3s.unice.fr/~tettaman/Classes/L2I/ProgSys/11_IntroSockets.pdf)

Explanations:

Accodring to the Armis BlueBorne results:

> To discover services, an SDP client sends an SDP request, and an appropriate response is returned. SDP defines yet another fragmentation mechanism for the SDP responses returned by an SDP server, called “SDP Continuation”. The SDP continuation works differently than normal fragmentation:
  > 1. First an SDP client will send an SDP request;
  > 2. If a response to this request exceeds the MTU of the established L2CAP connection, a fragment of the response will be returned, and a “continuation state” structure will be prepended to the SDP response.
  > 3. To receive the remaining fragments, the SDP client will send the​ ​same​ request again, appending to it the “continuation state” he received in the last response (this type of request is called a continuation request).
  > 4. The SDP server would then return the next fragment of the resp
  
> This can lead to the abuse of the continuation state, since the client is left to return it unchanged on each continuation request.
> This vulnerability is a direct result of the scenario described above - and is a very common mistake in implementations of fragmentation mechanisms. Since the SDP continuation struct is defined by the implementation, BlueZ decided to define this structure as its continuation state:

```
SDP Continuation Struct, as defined in BlueZ (src/sdpd-request.c):

typedef struct {
  uint32_t timestamp;
  union {
    uint16_t maxBytesSent;
    uint16_t lastIndexSent;
  } cStateValue;
} sdp_cont_state_t;
```

> This structure is comprised of a timestamp, which conveniently leaks the machine’s timestamp, and an index representing the total number of bytes that were sent so far.
> Since an attacker can control the continuation state sent on each request, he can change the index in the continuation struct, and cause the SDP server to return an out of bounds read from the response buffer:

```
Excerpt from SDP Search Attribute Request handler - service_search_attr_req (src/sdpd-request.c):

...
} else {
/* continuation State exists -> get from cache */
sdp_buf_t *pCache = sdp_get_cached_rsp(cstate);
if (pCache) {
  uint16_t sent = MIN(max, pCache->data_size - cstate->cStateValue.maxBytesSent);
  pResponse = pCache->data;
  memcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);
  buf->data_size += sent;
  cstate->cStateValue.maxBytesSent += sent;
  if (cstate->cStateValue.maxBytesSent == pCache->data_size)
    cstate_size = sdp_set_cstate_pdu(buf, NULL);
  else
    cstate_size = sdp_set_cstate_pdu(buf, cstate);
} ...
```

> This code from the Search Attribute Request handler of BlueZ SDP Server fails to validate maxBytesSent in cstate (the continuation state), and allows the above memcpy to copy data beyond the allocated size of pResponse. The only thing an attacker needs to do to achieve this information leak, is to avoid the if​ ​that validates all data has been sent (maxBytesSent == data_size) - and this can be easily done since he controls maxBytesSent. Since pResponse is allocated in the heap this information leak can lead to disclosure of highly sensitive data.

> BlueZ is comprised of two parts - one running in the kernel (as has been seen in the L2CAP vulnerability), and the other in the userspace. The bluetoothd process contains all of BlueZ’s user parts (essentially all layers of the stack above L2CAP). This process holds critical data that can be leaked using this vulnerability, such as encryption keys used in Bluetooth communications, enabling an attack that very much resembles heartbleed.


In order to enter the part of the code vulnerable we need to re-use an existing `continuation state`. 
To do so, we send a first SDP packet in order to receive the `sdp_cont_state_t.timestamp` of a `continuation state`.

Then we send a second packet using the same `timestamp` permitting to enter in the [vulnerable part of the code](https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L133).
Her we use `sdp_cont_state_t.maxBytesSent` as a pointer to the data we want to leak with the [vulnerable](https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L138) `memcpy()`  which does not control correctly the size of the returned data. 
