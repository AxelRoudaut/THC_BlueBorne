# Remote leak heap data from linux devices with bluetooth opened and discoverabled

***Cibles uniquement OS Linux***

```
Part1: gcc -o leak challenge_leak_part1.c -lbluetooth
Part2: gcc -o leak challenge_leak_part2.c -lbluetooth
Correction: gcc -o leak answers_leak.c -lbluetooth
Usage: sudo ./leak [Addr_BT_Target] [Leak_Offset]
```
Remarque: Pour pouvoir capturer des packets sur une interface bluetooth0 ou bluetooth1 installez:
```
sudo apt-get install libpcap0.8 libpcap0.8-dev libpcap-dev
```
Pour éviter de faire ramer la raspberry avec un affichage distant de Wireshark par `ssh -X`, nous allons capturer les flux Bluetooth avec tcpdump sur l'interface `bluetooth1`, envoyer ce flux sur un PC distant qui l'affichera avec son propre Wireshark.
```
ssh root@[addr raspberry] "sudo tcpdump -s 0 -U -n -i bluetooth1 -w -"  | sudo wireshark -k -i -
```
Plus d'info sur cette commande : [Creating a netcat pipe for wireshark for remote packet capture](https://www.techdodo.co.uk/creating-netcat-pipe-wireshark)

Remarque : Pour faciliter les connections ssh : [How To Set Up SSH Keys](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2) 

Lien vers le papier de recherche expliquant la vulnérabilité du code SDP: [Armis BlueBorne Technical Paper](http://go.armis.com/hubfs/BlueBorne%20Technical%20White%20Paper-1.pdf?t=1517293112971)

Lien vers le code Bluez avec la fonction SDP vulnérable [service_search_attr_req](https://sourcecodebrowser.com/bluez/4.81/sdpd-request_8c.html#a88a67e8cc83d0f53b65629478bc16a06)

Copie du code Bluez avec la partie vulnérable en surlignée:  https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L132-L144 

Quelques informations sur les fonctions utilisées dans le code C:
  - [socket()](http://pubs.opengroup.org/onlinepubs/7908799/xns/socket.html)
  - [bind()](http://pubs.opengroup.org/onlinepubs/7908799/xns/bind.html)
  - [connect()](http://pubs.opengroup.org/onlinepubs/7908799/xns/connect.html)
  - [send()](http://pubs.opengroup.org/onlinepubs/7908799/xns/send.html)
  - [recv()](http://pubs.opengroup.org/onlinepubs/7908799/xns/recv.html)
  - [Here more explanations about this functions](http://www.i3s.unice.fr/~tettaman/Classes/L2I/ProgSys/11_IntroSockets.pdf)

##Explications du Challenge

Le Session Description Protocol (SDP) est un protocole de communication de description de paramètres d'initialisation d'une session de diffusion en flux (streaming).



Accodring to the Armis BlueBorne results:

> To discover services, an SDP client sends an SDP request, and an appropriate response is returned. SDP defines yet another fragmentation mechanism for the SDP responses returned by an SDP server, called “SDP Continuation”. The SDP continuation works differently than normal fragmentation:
  > 1. First an SDP client will send an SDP request;
  > 2. If a response to this request exceeds the MTU of the established L2CAP connection, a fragment of the response will be returned, and a “continuation state” structure will be prepended to the SDP response.
  > 3. To receive the remaining fragments, the SDP client will send the​ ​same​ request again, appending to it the “continuation state” he received in the last response (this type of request is called a continuation request).
  > 4. The SDP server would then return the next fragment of the resp
  
> This can lead to the abuse of the continuation state, since the client is left to return it unchanged on each continuation request.
> This vulnerability is a direct result of the scenario described above - and is a very common mistake in implementations of fragmentation mechanisms. Since the SDP continuation struct is defined by the implementation, BlueZ decided to define this structure as its continuation state:

```
SDP Continuation Struct, as defined in BlueZ (src/sdpd-request.c):

typedef struct {
  uint32_t timestamp;
  union {
    uint16_t maxBytesSent;
    uint16_t lastIndexSent;
  } cStateValue;
} sdp_cont_state_t;
```

> This structure is comprised of a timestamp, which conveniently leaks the machine’s timestamp, and an index representing the total number of bytes that were sent so far.
> Since an attacker can control the continuation state sent on each request, he can change the index in the continuation struct, and cause the SDP server to return an out of bounds read from the response buffer:

```
Excerpt from SDP Search Attribute Request handler - service_search_attr_req (src/sdpd-request.c):

...
} else {
/* continuation State exists -> get from cache */
sdp_buf_t *pCache = sdp_get_cached_rsp(cstate);
if (pCache) {
  uint16_t sent = MIN(max, pCache->data_size - cstate->cStateValue.maxBytesSent);
  pResponse = pCache->data;
  memcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);
  buf->data_size += sent;
  cstate->cStateValue.maxBytesSent += sent;
  if (cstate->cStateValue.maxBytesSent == pCache->data_size)
    cstate_size = sdp_set_cstate_pdu(buf, NULL);
  else
    cstate_size = sdp_set_cstate_pdu(buf, cstate);
} ...
```

> This code from the Search Attribute Request handler of BlueZ SDP Server fails to validate maxBytesSent in cstate (the continuation state), and allows the above memcpy to copy data beyond the allocated size of pResponse. The only thing an attacker needs to do to achieve this information leak, is to avoid the if​ ​that validates all data has been sent (maxBytesSent == data_size) - and this can be easily done since he controls maxBytesSent. Since pResponse is allocated in the heap this information leak can lead to disclosure of highly sensitive data.

> BlueZ is comprised of two parts - one running in the kernel (as has been seen in the L2CAP vulnerability), and the other in the userspace. The bluetoothd process contains all of BlueZ’s user parts (essentially all layers of the stack above L2CAP). This process holds critical data that can be leaked using this vulnerability, such as encryption keys used in Bluetooth communications, enabling an attack that very much resembles heartbleed.


In order to enter the part of the code vulnerable we need to re-use an existing `continuation state`. 
To do so, we send a first SDP packet in order to receive the `sdp_cont_state_t.timestamp` of a `continuation state`.

Then we send a second packet using the same `timestamp` permitting to enter in the [vulnerable part of the code](https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L133).
Her we use `sdp_cont_state_t.maxBytesSent` as a pointer to the data we want to leak with the [vulnerable](https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L138) `memcpy()`  which does not control correctly the size of the returned data. 
