# Remote leak heap data from linux devices with bluetooth opened and discoverabled

***Cibles uniquement OS Linux***

```
Part1: gcc -o leak challenge_leak_part1.c -lbluetooth
Part2: gcc -o leak challenge_leak_part2.c -lbluetooth
Correction: gcc -o leak answers_leak.c -lbluetooth
Usage: sudo ./leak [Addr_BT_Target] [Leak_Offset]
```
Remarque: Pour pouvoir capturer des packets sur une interface bluetooth0 ou bluetooth1 installez:
```
sudo apt-get install libpcap0.8 libpcap0.8-dev libpcap-dev
```
Pour éviter de faire ramer la raspberry avec un affichage distant de Wireshark par `ssh -X`, nous allons capturer les flux Bluetooth avec tcpdump sur l'interface `bluetooth1`, envoyer ce flux sur un PC distant qui l'affichera avec son propre Wireshark.
```
ssh root@[addr raspberry] "sudo tcpdump -s 0 -U -n -i bluetooth1 -w -"  | sudo wireshark -k -i -
```
Plus d'info sur cette commande : [Creating a netcat pipe for wireshark for remote packet capture](https://www.techdodo.co.uk/creating-netcat-pipe-wireshark)

Remarque : Pour faciliter les connections ssh : [How To Set Up SSH Keys](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2) 

Lien vers le papier de recherche expliquant la vulnérabilité du code SDP: [Armis BlueBorne Technical Paper](http://go.armis.com/hubfs/BlueBorne%20Technical%20White%20Paper-1.pdf?t=1517293112971)

Lien vers le code Bluez avec la fonction SDP vulnérable [service_search_attr_req](https://sourcecodebrowser.com/bluez/4.81/sdpd-request_8c.html#a88a67e8cc83d0f53b65629478bc16a06)

Copie du code Bluez avec la partie vulnérable en surlignée:  https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L132-L144 

Quelques informations sur les fonctions utilisées dans le code C:
  - [socket()](http://pubs.opengroup.org/onlinepubs/7908799/xns/socket.html)
  - [bind()](http://pubs.opengroup.org/onlinepubs/7908799/xns/bind.html)
  - [connect()](http://pubs.opengroup.org/onlinepubs/7908799/xns/connect.html)
  - [send()](http://pubs.opengroup.org/onlinepubs/7908799/xns/send.html)
  - [recv()](http://pubs.opengroup.org/onlinepubs/7908799/xns/recv.html)
  - [Here more explanations about this functions](http://www.i3s.unice.fr/~tettaman/Classes/L2I/ProgSys/11_IntroSockets.pdf)

## Explications de la vulnérabilité

Le Session Description Protocol (SDP) est un protocole de communication de description de paramètres d'initialisation d'une session de diffusion en flux (streaming).

Pour découvrir des services, un client SDP envoie une `SDP request` et attends le retour d'une réponse appropriée du serveur SDP. Le protocol SDP dispose d'un méchanisme de fragmentation pour les `SDP responses` retournées par un serveur SDP. Ce méchanisme de fragmentation appelé `SDP Continuation` focntionne de manière un peu différente d'un méchanisme de fragmentation "normal".

  1. Le client envoie une `SDP request` 
  2. Si la réponse dépasse la `MTU` définie lors de la connections L2CAP (672 par défault), un premier fragment de la réponse est retourné dans lequel est ajouté la structure `continuation state`.
  3. Pour recevoir les fragments restatns, le client SDP doit re-envoyer la même `SDP request` en y ajoutant cette fois le `continuation state` qu'il a reçu lors de la précedente réponse. Ce type de requête est appelé `continuation request`.
  4. Le serveur SDP envoie alors le fragment de réponse suivant. 

Il est possible d'abuser de ce méchanisme de `continuation state` du fait que le client est libre de modifier ses valeurs à chaque `continuation request` .

```
SDP Continuation Struct, as defined in BlueZ (src/sdpd-request.c):

typedef struct {
  uint32_t timestamp;
  union {
    uint16_t maxBytesSent;
    uint16_t lastIndexSent;
  } cStateValue;
} sdp_cont_state_t;
```

Cette structure permet aisément de récuper le `timestamp` de la machine cible, permettant au serveur SDP d'entrer dans certaines partie de code (il va utiliser des données mis en cache lorsqu'il voit un paquet SDP avec le même `timestamp`).

Et comme un attaquant peut contrôler facilement la structure du `continuation state` envoyé à chaque requêtes, il peut modifier ses valeurs, notamment l'index `maxBytesSent` que l'on va utiliser comme un pointeur d'adresse pour fuire des données.

```
Excerpt from SDP Search Attribute Request handler - service_search_attr_req (src/sdpd-request.c):

...
} else {
/* continuation State exists -> get from cache */
sdp_buf_t *pCache = sdp_get_cached_rsp(cstate);
if (pCache) {
  uint16_t sent = MIN(max, pCache->data_size - cstate->cStateValue.maxBytesSent);
  pResponse = pCache->data;
  memcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);
  buf->data_size += sent;
  cstate->cStateValue.maxBytesSent += sent;
  if (cstate->cStateValue.maxBytesSent == pCache->data_size)
    cstate_size = sdp_set_cstate_pdu(buf, NULL);
  else
    cstate_size = sdp_set_cstate_pdu(buf, cstate);
} ...
```

Ci-dessus, la partie du code vulnérable dans Bluez SDP Server. On remarque que ce code situé dans la fonction `service_search_attr_req` de `sdpd-request.c.` ne valide pas correctement le `maxByteSent` provenant du `cstate` et permet alors d'utiliser le `memcpy` pour copier des données au-delà de la taille allouée par `pResponse` en utlisant cette valeur de `maxByteSent` comme pointeur des données à faire fuire.

La seule chose qu'un attaquant doit réaliser pour réussir ce `leak` est d'empêcher la validation des données à envoyer `maxByteSent == data_size), ce qu'il peut faire facilement car il contrôle la valeur de maxByteSent.

La valeur de `pResponse` étant stoquée sur la `Heap`, cette fuite d'information peut permettre à l'attaquant d'y trouver d'autres données sensibles comme des clés de chiffrement utilisées dans les protocoles de communication, etc...


## Explication du Challenge



In order to enter the part of the code vulnerable we need to re-use an existing `continuation state`. 
To do so, we send a first SDP packet in order to receive the `sdp_cont_state_t.timestamp` of a `continuation state`.

Then we send a second packet using the same `timestamp` permitting to enter in the [vulnerable part of the code](https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L133).
Her we use `sdp_cont_state_t.maxBytesSent` as a pointer to the data we want to leak with the [vulnerable](https://github.com/AxelRoudaut/THC_BlueBorne/blob/2886f0c607d69879865177c09ae8c8eda229cb69/Linux_Exploit/perso/LEAK_CVE-2017-1000250/service_search_attr_req#L138) `memcpy()`  which does not control correctly the size of the returned data. 
