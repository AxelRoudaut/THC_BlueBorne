# Remote crash most linux devices with bluetooth open

***Only for linux devices***

## Explication de la vulnérabilité

**Description du *Logical link control and adaptation protocol* (L2CAP)**

Côté hôte, la couche la plus basse de la pile Bluetooth est L2CAP. Cette couche est responsable de gérer les connexions aux différents services Bluetooth et de transmettre les paquets au *Host Controller Interface* (HCI).


En général, L2CAP peut être considéré comme l'équivalent de Bluetooth de TCP et ses fonctions sont :

- Transport de données pour les protocoles de couche supérieure, y compris le multiplexage de plusieurs applications sur un même lien.
- Segmentation et réassemblage des paquets.
- Fourniture d'une gestion de transmission unidirectionnelle des données de multicast à un groupe d'autres périphériques Bluetooth.
- Gestion de la qualité de service (QoS) pour les protocoles de couche supérieure.

La spécification Bluetooth réserve des CID spécifiques (identifiants de canaux) à des fins fixes, par exemple, CID 0x0001 se référera toujours au canal de signalisation dans lequel les paquets de contrôle sont passés (et à travers eux - de nouvelles connexions peuvent être établies). Les autres CID sont gérés et alloués dynamiquement.

Les divers services via Bluetooth ont souvent des PSM fixes (Protocol / Service Multiplexer - un autre terme L2CAP signifiant le numéro de port). Un point de terminaison souhaitant se connecter à ces services enverrait un message L2CAP ConnectionRequest à ce PSM spécifique. En réponse à ce message, un CID dynamique serait alloué pour identifier la connexion à ce service spécifique.

**Le processus de configuration** a lieu à l'aide de demandes de configuration et de réponses, appelées dans la spécification `L2CAP_ConfReq` et `L2CAP_ConfResp`. Chaque extrémité négocie sa propre configuration, ce qui signifie que les paramètres de configuration des deux points de terminaison doivent être convenus. Un exemple de configuration de MTU ci-dessous.

![alt text](https://github.com/AxelRoudaut/THC_BlueBorne/blob/master/images/l2cap_mutual_conf.PNG)

Il existe 2 types de processus de configuration:
  * “The standard configuration process”* dans lequel les extrémités répondront à une demande de configuration avec une réponse
qui accepte ou rejette la configuration offerte. Si une configuration a été rejetée, les terminaux continueront à négocier jusqu'à ce qu'ils atteignent une configuration convenue.
  * “The lockstep configuration process”*. This process is required to facilitate the Extended Flow Specification (EFS​) feature of L2CAP, which allows devices to establish a more comprehensive connection. The EFS feature parameters will need to be validated with each of the endpoints local Bluetooth controller, and so the endpoints response to a configuration request may be “Pending”. Once both EFS parameters have been exchanged between the endpoints, and the validation of EFS is achieved, a final response will be returned by each of the endpoints.
  
**Linux kernel RCE vulnerability - CVE-2017-1000251**

La vulnérabilité réside dans l'implémentation par BlueZ de la fonctionnalité EFS de L2CAP nommée `l2cap_parse_conf_rsp`.

  - [l2cap_parse_conf_rsp](https://elixir.bootlin.com/linux/v3.12.36/source/net/bluetooth/l2cap_core.c#L3482)
      ```
      Excerpt from l2cap_parse_conf_rsp (net/bluetooth/l2cap_core.c):

      static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len, void *data, u16 *result) 
      {
        struct l2cap_conf_req *req = data;
        void *ptr = req->data;
        // ...
        while (len >= L2CAP_CONF_OPT_SIZE) {
          len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);
            switch (type) {

            case L2CAP_CONF_MTU:
              // Validate MTU...
              l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu);
              break;

            case L2CAP_CONF_FLUSH_TO:
              chan->flush_to = val;
              l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
              2, chan->flush_to);
              break;
          // ...
          }
        }
        // ...
        return ptr - data;
      }
      ```

Cette fonction reçoit un buffer (=tampon) de réponse de configuration (dans l'argument `rsp`) et sa longueur (dans l'argument `len`). Il extrait les éléments du tampon un par un à l'aide de la fonction `l2cap_get_conf_opt`, jusqu'à ce que l'argument `len` soit épuisé. Chaque élément qu'il décompresse de la réponse de la configuration est validé puis remis dans un tampon de réponse, pointé par l'argument de données.
Toutefois, la taille de ce buffer de réponse n'est pas transmise dans la fonction. Donc fondamentalement, tous les éléments de la RSP seraient copiés dans le tampon de données via `& ptr` (offset à `l2cap_conf_req.data`) quelle que soit la taille de la mémoire du buffer de la cible.
Notez également que la taille de la réponse entrante n'étant pas limitée - les éléments peuvent être dupliqués, ce qui permet à un attaquant de contrôler la taille du buffer `rsp` et, par conséquent, la quantité de données copiées sur les données.

L'origine du buffer de données dans `l2cap_parse_conf_rsp` est appelée à partir de deux emplacements, tous deux dans une fonction appelée `l2cap_config_rsp`, qui, comme son nom l'indique, gère les messages de réponse de configuration. Les deux invocations sont similaires, donc les deux peuvent être utilisés pour exploiter cette vulnérabilité.

  - [l2cap_config_rsp](https://elixir.bootlin.com/linux/v3.12.36/source/net/bluetooth/l2cap_core.c#L4081)
       ```
      Excerpt from l2cap_config_rsp (net/bluetooth/l2cap_core.c):

      switch (result) {
      case L2CAP_CONF_SUCCESS:
        // ...
        break;
      case L2CAP_CONF_PENDING:
        set_bit(CONF_REM_CONF_PEND, &chan->conf_state);
        if (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {
          char buf[64];
          len = l2cap_parse_conf_rsp(chan, rsp->data, len, buf, &result);
        // ...
        goto done;
      // ...
      ``` 

Le `switch` examine la valeur de résultat, qui a été précédemment décompressée à partir du paquet de réponse de configuration, et peut donc être contrôlée par un attaquant. Le buffer de réponse est un petit buffer de pile, nommé `buf`, déclaré dans la portée de l'instruction `if` qui conduit à l'appel.

La configuration du canal actuel est ensuite testée pour l'état `PENDING` (comme décrit ci-dessus dans le processus de configuration *lockstep*). Donc, pour accéder à ce flux, un attaquant a besoin que sa cible soit dans l'état `PENDING`.

  - [l2cap_parse_conf_req](https://elixir.bootlin.com/linux/v3.12.36/source/net/bluetooth/l2cap_core.c#L3268)
  
      ```
      Excerpt from l2cap_parse_conf_req (net/bluetooth/l2cap_core.c) :
	
      if (result == L2CAP_CONF_SUCCESS) {
        /* Configure output options and let the other side know
         * which ones we don't like. */
        // ...
        if (remote_efs) {
        if (chan->local_stype != L2CAP_SERV_NOTRAFIC &&
            efs.stype != L2CAP_SERV_NOTRAFIC &&
            efs.stype != chan->local_stype) {
          // We don’t want this branch, easy to avoid
          // ...
        } else {
           /* Send PENDING Conf Rsp */
           result = L2CAP_CONF_PENDING;
           set_bit(CONF_LOC_CONF_PEND, &chan->conf_state);
        }
      }
      // ...
      ```

Cette action est simple: un attaquant doit seulement envoyer une demande de configuration avec un élément EFS, en définissant le champ `stype` sur `L2CAP_SERV_NOTRAFIC`.

Lorsque l'état `PENDING` est atteint, la réponse de configuration suivante envoyée avec le champ résultat défini sur `L2CAP_CONF_PENDING` déclenche la vulnérabilité, amenant le tampon `buf [64]` à être remplacé par un tampon de taille arbitraire.

Cette vulnérabilité permet à un attaquant de déborder un tampon de 64 octets sur la pile du noyau par une quantité illimitée de données, à condition qu'elle soit conforme à la structure d'une réponse de configuration L2CAP valide.


**Exploitabilité**

Aujourd'hui, un débordement de pile comme la vulnérabilité décrite ci-dessus ne se traduit pas automatiquement par l'exécution de code. Les systèmes d'exploitation modernes ont des techniques d'atténuation spécialement conçues pour prévenir les vulnérabilités de corruption de la mémoire résultant de l'exécution de code (c'est pourquoi sur notre Ubuntu cible, cette attaque n'aboutira uniquement qu'à un déni de service). Malgré cela, le noyau Linux est parfois à la traîne dans l'implémentation de certaines *mitigations* modernes avec les configurations par défaut.

**Impact**

Dans le cas de BlueZ, L2CAP est inclus dans le noyau du noyau Linux. C'est un choix plutôt dangereux. La combinaison d'un protocole de communication entièrement exposé, des fonctionnalités arcanes comme EFS et une implémentation de l'espace noyau est une recette pour les problèmes. Cette vulnérabilité est un débordement de pile classique se produisant dans le contexte d'un thread de noyau. Cela fournit à un attaquant un exploit au niveau du noyau complet et fiable pour tout périphérique compatible Bluetooth sous Linux, ne nécessitant aucune étape supplémentaire. De plus, chaque hôte compromis peut être utilisé pour lancer des attaques secondaires, ce qui rend cette vulnérabilité vermifuge.
