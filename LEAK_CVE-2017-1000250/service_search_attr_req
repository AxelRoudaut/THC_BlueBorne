static int service_search_attr_req(sdp_req_t * req, sdp_buf_t *	buf)
{
       int status = 0, plen, totscanned;
       uint8_t *pdata, *pResponse = NULL;
       unsigned int max;
       int scanned, rsp_count = 0;
       sdp_list_t *pattern = NULL, *seq = NULL, *svcList;
       sdp_cont_state_t *cstate = NULL;
       short cstate_size = 0;
       uint8_t dtd = 0;
       sdp_buf_t tmpbuf;
       size_t data_left = req->len;

       tmpbuf.data = NULL;
       pdata = req->buf + sizeof(sdp_pdu_hdr_t);
       data_left = req->len - sizeof(sdp_pdu_hdr_t);
       scanned = extract_des(pdata, data_left, &pattern, &dtd, SDP_TYPE_UUID);
       if (scanned == -1) {
              status = SDP_INVALID_SYNTAX;
              goto done;
       }
       totscanned = scanned;

       SDPDBG("Bytes scanned: %d", scanned);

       pdata += scanned;
       data_left -= scanned;

       if (data_left < sizeof(uint16_t)) {
              status = SDP_INVALID_SYNTAX;
              goto done;
       }

       max = ntohs(bt_get_unaligned((uint16_t *)pdata));

       pdata += sizeof(uint16_t);
       data_left -= sizeof(uint16_t);

       SDPDBG("Max Attr expected: %d", max);

       if (data_left < sizeof(sdp_pdu_hdr_t)) {
              status = SDP_INVALID_SYNTAX;
              goto done;
       }

       /* extract the attribute list */
       scanned = extract_des(pdata, data_left, &seq, &dtd, SDP_TYPE_ATTRID);
       if (scanned == -1) {
              status = SDP_INVALID_SYNTAX;
              goto done;
       }

       pdata += scanned;
       data_left -= scanned;

       totscanned += scanned + sizeof(uint16_t) + 1;

       plen = ntohs(((sdp_pdu_hdr_t *)(req->buf))->plen);
       if (plen < totscanned || plen != totscanned + *(uint8_t *)pdata) {
              status = SDP_INVALID_PDU_SIZE;
              goto done;
       }

       /*
        * if continuation state exists attempt
        * to get rsp remainder from cache, else send error
        */
       if (sdp_cstate_get(pdata, data_left, &cstate) < 0) {
              status = SDP_INVALID_SYNTAX;
              goto done;
       }

       svcList = sdp_get_record_list();

       tmpbuf.data = malloc(USHRT_MAX);
       tmpbuf.data_size = 0;
       tmpbuf.buf_size = USHRT_MAX;
       memset(tmpbuf.data, 0, USHRT_MAX);

       /*
        * Calculate Attribute size acording to MTU
        * We can send only (MTU - sizeof(sdp_pdu_hdr_t) - sizeof(sdp_cont_state_t))
        */
       max = MIN(max, req->mtu - sizeof(sdp_pdu_hdr_t) - SDP_CONT_STATE_SIZE - sizeof(uint16_t));

       /* pull header for AttributeList byte count */
       buf->data += sizeof(uint16_t);
       buf->buf_size -= sizeof(uint16_t);

       if (cstate == NULL) {
              /* no continuation state -> create new response */
              sdp_list_t *p;
              for (p = svcList; p; p = p->next) {
                     sdp_record_t *rec = p->data;
                     if (sdp_match_uuid(pattern, rec->pattern) > 0 &&
                                   sdp_check_access(rec->handle, &req->device)) {
                            rsp_count++;
                            status = extract_attrs(rec, seq, &tmpbuf);

                            SDPDBG("Response count : %d", rsp_count);
                            SDPDBG("Local PDU size : %d", tmpbuf.data_size);
                            if (status) {
                                   SDPDBG("Extract attr from record returns err");
                                   break;
                            }
                            if (buf->data_size + tmpbuf.data_size < buf->buf_size) {
                                   // to be sure no relocations
                                   sdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);
                                   tmpbuf.data_size = 0;
                                   memset(tmpbuf.data, 0, USHRT_MAX);
                            } else {
                                   error("Relocation needed");
                                   break;
                            }
                            SDPDBG("Net PDU size : %d", buf->data_size);
                     }
              }
              if (buf->data_size > max) {
                     sdp_cont_state_t newState;

                     memset((char *)&newState, 0, sizeof(sdp_cont_state_t));
                     newState.timestamp = sdp_cstate_alloc_buf(buf);
                     /*
                      * Reset the buffer size to the maximum expected and
                      * set the sdp_cont_state_t
                      */
                     buf->data_size = max;
                     newState.cStateValue.maxBytesSent = max;
                     cstate_size = sdp_set_cstate_pdu(buf, &newState);
              } else
                     cstate_size = sdp_set_cstate_pdu(buf, NULL);
       } else {
              /* continuation State exists -> get from cache */
              sdp_buf_t *pCache = sdp_get_cached_rsp(cstate);
              if (pCache) {
                     uint16_t sent = MIN(max, pCache->data_size - cstate->cStateValue.maxBytesSent);
                     pResponse = pCache->data;
                     memcpy(buf->data, pResponse + cstate->cStateValue.maxBytesSent, sent);
                     buf->data_size += sent;
                     cstate->cStateValue.maxBytesSent += sent;
                     if (cstate->cStateValue.maxBytesSent == pCache->data_size)
                            cstate_size = sdp_set_cstate_pdu(buf, NULL);
                     else
                            cstate_size = sdp_set_cstate_pdu(buf, cstate);
              } else {
                     status = SDP_INVALID_CSTATE;
                     SDPDBG("Non-null continuation state, but null cache buffer");
              }
       }

       if (!rsp_count && !cstate) {
              // found nothing
              buf->data_size = 0;
              sdp_append_to_buf(buf, tmpbuf.data, tmpbuf.data_size);
              sdp_set_cstate_pdu(buf, NULL);
       }

       // push header
       buf->data -= sizeof(uint16_t);
       buf->buf_size += sizeof(uint16_t);

       if (!status) {
              /* set attribute list byte count */
              bt_put_unaligned(htons(buf->data_size - cstate_size), (uint16_t *)buf->data);
              buf->data_size += sizeof(uint16_t);
       }

done:
       free(cstate);
       free(tmpbuf.data);
       if (pattern)
              sdp_list_free(pattern, free);
       if (seq)
              sdp_list_free(seq, free);
       return status;
}

